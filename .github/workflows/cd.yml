name: CD - Deploy to Kubernetes

on:
  workflow_run:
    workflows: ["CI - Build & Push Docker"]
    types: [ "completed" ]

permissions:
  contents: read

env:
  CI_SHA: ${{ github.event.workflow_run.head_sha }}

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set vars
        id: vars
        shell: bash
        run: |
          IMAGE="${{ secrets.DOCKERHUB_IMAGE || 'adrianbranche/monitor:latest' }}"
          TAG_SHA="${CI_SHA::7}"
          NS="${{ secrets.K8S_NAMESPACE || 'default' }}"
          echo "IMAGE=$IMAGE"     >> "$GITHUB_OUTPUT"
          echo "TAG_SHA=$TAG_SHA" >> "$GITHUB_OUTPUT"
          echo "NAMESPACE=$NS"    >> "$GITHUB_OUTPUT"

      - name: Decide if we have kubeconfig
        id: gate
        shell: bash
        run: |
          if [ -n "${{ secrets.KUBE_CONFIG_DATA }}" ]; then
            echo "DO_DEPLOY=true"  >> "$GITHUB_OUTPUT"
          else
            echo "DO_DEPLOY=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Skip deploy (no kubeconfig present)
        if: steps.gate.outputs.DO_DEPLOY != 'true'
        run: |
          echo "KUBE_CONFIG_DATA não definido. Pulando kubectl."
          echo "A imagem publicada foi: ${{ steps.vars.outputs.IMAGE }}:${{ steps.vars.outputs.TAG_SHA }}"
          echo "Se você usa estratégia pull-based (ex.: Keel no cluster), o update ocorrerá automaticamente."
          exit 0

      - name: Setup kubectl
        if: steps.gate.outputs.DO_DEPLOY == 'true'
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Configure kubeconfig
        if: steps.gate.outputs.DO_DEPLOY == 'true'
        shell: bash
        run: |
          mkdir -p "$HOME/.kube"
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > "$HOME/.kube/config"
          chmod 600 "$HOME/.kube/config"

      - name: Create namespace if not exists (pwsh)
        if: steps.gate.outputs.DO_DEPLOY == 'true'
        shell: pwsh
        env:
          K8S_NAMESPACE: ${{ steps.vars.outputs.NAMESPACE }}
        run: |
          kubectl get ns $env:K8S_NAMESPACE
          if ($LASTEXITCODE -ne 0) {
            kubectl create ns $env:K8S_NAMESPACE
          }

      - name: Apply base manifests (optional)
        if: steps.gate.outputs.DO_DEPLOY == 'true'
        shell: bash
        run: |
          NS="${{ steps.vars.outputs.NAMESPACE }}"
          for f in k8s/service.yaml k8s/prometheus-deployment.yaml k8s/grafana-deployment.yaml k8s/nginx-deployment.yaml k8s/nginx-service.yaml k8s/prometheus-config.yaml; do
            [ -f "$f" ] && kubectl apply -n "$NS" -f "$f" || true
          done

      - name: Apply app deployment (first time)
        if: steps.gate.outputs.DO_DEPLOY == 'true'
        run: |
          kubectl apply -n "${{ steps.vars.outputs.NAMESPACE }}" -f k8s/deployment.yaml

      - name: Set image to new tag
        if: steps.gate.outputs.DO_DEPLOY == 'true'
        run: |
          kubectl set image -n "${{ steps.vars.outputs.NAMESPACE }}" \
            deployment/monitor \
            monitor="${{ steps.vars.outputs.IMAGE }}:${{ steps.vars.outputs.TAG_SHA }}"

      - name: Wait rollout
        if: steps.gate.outputs.DO_DEPLOY == 'true'
        run: |
          kubectl rollout status deployment/monitor -n "${{ steps.vars.outputs.NAMESPACE }}" --timeout=180s

      - name: Show services (debug)
        if: steps.gate.outputs.DO_DEPLOY == 'true'
        run: |
          kubectl get ns
          kubectl get all -n "${{ steps.vars.outputs.NAMESPACE }}"
